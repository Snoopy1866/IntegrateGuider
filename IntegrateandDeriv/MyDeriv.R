#-------------------------------------数值微分 by 李威仪-----------------------------------------------------
#-----------------------理查森外推法--------------------------
Waitui<-function(f,x,h)                                      
  #f为所要求导的函数，x为所求导数的函数值，h为初始步长#
{
  z<-matrix(NA,9,9)                                                                   
  for (i in 1:9)
  {
    for (j in 1:9)
    {
      if(j==1)                                            
        #利用中点公式计算出第一列#
      {
        z[i,j]<-(1/(2*h/(2^(i-1))))*(f(x+(h/2^(i-1)))-f(x-(h/2^(i-1))))
      }
      else                                                
        #利用理查森外推法计算微分#
      {
        if(i-j>=0)
        {
          z[i,j]<-(4^(j-1)*z[i,j-1]-z[i-1,j-1])/(4^(j-1)-1)
        }
      }
    }
  }
  return(cat("导数值为 ", z[9,9],"\n"))
}
#-----------------------两点法--------------------------
TwoPoint<-function(x,y)
{
  #x为自变量，y为因变量
  h <- x[2] - x[1] 
  #计算步长
  p1 <- c((1/h)*(y[2] - y[1]),(1/h)*(y[2] - y[1]))
  #利用两点公式计算出两个点的导数值
  return(cat("节点上的导数值依次为 ",p1,"\n"))
}
#-----------------------三点法--------------------------
ThreePoint<-function(x,y)
{
  #x为自变量，y为因变量
  h <- x[2] - x[1]
  #计算步长
  p2 <- c((1/(2*h))*( - 3*y[1] + 4*y[2] - y[3]),(1/(2*h))*( - y[1] + y[3]),(1/(2*h))*(y[1] - 4*y[2] + 3*y[3]))
  #利用三点公式计算出三个点的导数值
  return(cat("节点上的导数值依次为 ",p2,"\n"))
}
#-----------------------三次样条求导法--------------------------
CubicSpline<-function(x,y,b,bz = NULL)
  #x自变量，y因变量，b为边界条件,bz为边界值
{
  n<-length(x)
  z<-matrix(0,n,n)
  #构建系数矩阵的初始矩阵
  h<-rep(0,n-1)
  h[1:(n-1)]<-x[2:n]-x[1:(n-1)]
  #计算步长
  if(b==1)
    #已知两端的一阶导数值时
  {
    u<-rep(1,n-1)
    v<-rep(1,n-1)
    d<-rep(0,n)
    #给定初始的miu,lamuda和d
    d[1]<-6/(h[1])*((y[2]-y[1])/(x[2]-x[1])-bz[1])
    d[n]<-6/(h[n-1])*(bz[2]-(y[n]-y[n-1])/(x[n]-x[n-1]))
    v[2:(n-1)]<-h[2:(n-1)]/(h[1:(n-2)]+h[2:(n-1)])
    d[2:(n-1)]<-6*(((y[3:n]-y[2:(n-1)])/(x[3:n]-x[2:(n-1)])-
                      (y[2:(n-1)]-y[1:(n-2)])/(x[2:(n-1)]-x[1:(n-2)]))/(x[3:n]-x[1:(n-2)])) 
    u[1:(n-2)]<-h[1:(n-2)]/(h[2:(n-1)]+h[1:(n-2)])
    #计算出该条件下的miu,lamuda和d值
    diag(z) <- 2
    for (i in 1:(n-1))
    {
      z[i,i+1]<-v[i]
    }
    for (i in 2:n)
    {
      z[i,i-1]<-u[i-1]
    }
    #给系数矩阵赋值
    m<-solve(z,d)
    #解此矩阵求得M的值
    a1<- - m[1:(n-1)]/(6*h[1:(n-1)])
    a2<-m[2:n]/(6*h[1:(n-1)])
    a3<- - (y[1:(n-1)]-m[1:(n-1)]*h[1:(n-1)]^2/6)/h[1:(n-1)]
    a4<-(y[2:n]-(m[2:n]*h[1:(n-1)]^2)/6)/h[1:(n-1)]
    A<-matrix(NA,n-1,4)
    A[1:(n-1),]<-c(a1[1:(n-1)],a2[1:(n-1)],a3[1:(n-1)],a4[1:(n-1)])
    #将M代入表达式计算出三次样条函数的系数并赋给矩阵A
  }
  if(b==2)
    #已知两端的二阶导数值时
  {
    u<-rep(0,n-1)
    v<-rep(0,n-1)
    d<-rep(0,n)
    #给定初始的miu,lamuda和d
    d[1]<-2*bz[1]
    d[n]<-2*bz[2]
    v[2:(n-1)]<-h[2:(n-1)]/(h[1:(n-2)]+h[2:(n-1)])
    d[2:(n-1)]<-6*( ((y[3:n]-y[2:(n-1)])/(x[3:n]-x[2:(n-1)])-
                       (y[2:(n-1)]-y[1:(n-2)])/(x[2:(n-1)]-x[1:(n-2)]))/(x[3:n]-x[1:(n-2)]) ) 
    u[1:(n-2)]<-h[1:(n-2)]/(h[2:(n-1)]+h[1:(n-2)])
    #计算出该条件下的miu,lamuda和d值
    diag(z) <- 2
    for (i in 1:(n-1))
    {
      z[i,i+1]<-v[i]
    }
    for (i in 2:n)
    {
      z[i,i-1]<-u[i-1]
    }
    #给系数矩阵赋值
    m<-solve(z,d)
    #解此矩阵求得M的值
    a1<- - m[1:(n-1)]/(6*h[1:(n-1)])
    a2<-m[2:n]/(6*h[1:(n-1)])
    a3<- - (y[1:(n-1)]-m[1:(n-1)]*h[1:(n-1)]^2/6)/h[1:(n-1)]
    a4<-(y[2:n]-(m[2:n]*h[1:(n-1)]^2)/6)/h[1:(n-1)]
    A<-matrix(NA,n-1,4)
    A[1:(n-1),]<-c(a1[1:(n-1)],a2[1:(n-1)],a3[1:(n-1)],a4[1:(n-1)])
    #将M代入表达式计算出三次样条函数的系数并赋给矩阵A
  }
  if(b==3)
    #原始函数为周期函数时
  {
    g<-matrix(0,n-1,n-1)
    #构建此条件下的系数矩阵的初始矩阵
    d<-rep(NA,n-1)
    u<-rep(NA,n-1)
    v<-rep(NA,n-1)
    #给定初始的miu,lamuda和d
    v[1:(n-2)]<-h[2:(n-1)]/(h[1:(n-2)]+h[2:(n-1)])
    u[1:(n-2)]<-h[1:(n-2)]/(h[1:(n-2)]+h[2:(n-1)])
    d[1:(n-2)]<-6*(((y[3:n]-y[2:(n-1)])/(h[2:(n-1)])-
                      (y[2:(n-1)]-y[1:(n-2)])/(h[1:(n-2)]))/(h[1:(n-2)]+h[2:(n-1)]))
    v[n-1]<-h[1]/(h[n-1]+h[1])
    u[n-1]<-1 - v[n-1]
    d[n-1]<-6*(((y[2]-y[1])/(h[1])-(y[n]-y[n-1])/(h[n-1]))/(h[1]+h[n-1])) 
    #计算出该条件下的miu,lamuda和d值
    g[1,n-1]<-u[1]
    g[n-1,1]<-v[n-1]
    diag(g) <- 2
    for (i in 1:(n-2))
    {
      g[i,i+1]<-v[i]
    }
    for (i in 2:(n-1))
    {
      g[i,i-1]<-u[i]
    }
    #给系数矩阵赋值
    m<-solve(g,d)
    m<-c(m[n-1],m)
    #解此矩阵，并求得M的值
    a1<- - m[1:(n-1)]/(6*h[1:(n-1)])
    a2<-m[2:n]/(6*h[1:(n-1)])
    a3<- - (y[1:(n-1)]-(m[1:(n-1)]*h[1:(n-1)]^2)/6)/h[1:(n-1)]
    a4<-(y[2:n]-(m[2:n]*h[1:(n-1)]^2)/6)/h[1:(n-1)]
    A<-matrix(NA,n-1,4)
    A[1:(n-1),]<-c(a1[1:(n-1)],a2[1:(n-1)],a3[1:(n-1)],a4[1:(n-1)])
    #将M代入表达式计算出三次样条函数的系数并赋给矩阵A
  }
  return(A)
  #A用作函数中的返回值
}
CubicSplineDeriv<-function(x,y,x.value,b,bz = NULL)
  #x自变量，y因变量，b为边界条件,bz为边界值,x.value为所要求导数值的点的横坐标值
{
  if(!(length(x)>=2 && length(x)==length(y)))
  {
    stop("插值点的个数小于2或者输入坐标有误")
  }
  if ((any(b == c(1:2)) && length(bz) != 2))
  {
    stop("边界条件不足或过多")
  }
  if (b == 3 && !is.null(bz))
  {
    stop("边界条件是多余的")
  }
  
  #排除异常数据
  A<-CubicSpline(x,y,b,bz)
  #引用函数
  n<-length(x)
  if(x.value<x[1] || x.value>x[n])
  {
    stop("x值不在三次样条的区间范围内，无法计算!")
  }
  #排除掉超出范围的异常坐标点
  else
  {
    if (x.value == x[1])
    {
      S<-A[1,1]*3*(x.value-x[2])^2 + A[1,2]*3*(x.value-x[1])^2 + A[1,3] + A[1,4]
    }
    else if (x.value == x[n])
    {
      S<-A[n - 1,1]*3*(x.value-x[n])^2 + A[n - 1,2]*3*(x.value-x[n - 1])^2 + A[n - 1,3] + A[n - 1,4]
    }
    else
    {
      t <- NULL
      t[x <= x.value] <- 0
      t[x > x.value] <- 1
      i <- which(cumsum(t) == 1) - 1
      #选取使用哪一个区间范围内的三次样条函数
      S<-A[i,1]*3*(x.value-x[i+1])^2+A[i,2]*3*(x.value-x[i])^2+A[i,3]+A[i,4]
    }
    
    #利用多项式的求导得到了求导后的三次样条函数，然后计算出所求的导数值S
  }
  return(cat("导数值为 ",S,"\n"))
}